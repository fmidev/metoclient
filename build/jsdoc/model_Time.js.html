<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: model/Time.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: model/Time.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Time model for animator.
 * @author Finnish Meteorological Institute
 * @license MIT
 */

import * as utils from '../utils'
import * as constants from '../constants'
import EventEmitter from 'wolfy87-eventemitter'
import isNumeric from 'fast-isnumeric'

export default class Time {
  /**
   *  Constructs a new time model.
   *  @param {Object} config User configuration.
   *  @constructor
   */
  constructor (config) {
    this.config_ = config
    this.variableEvents = new EventEmitter()
    this.actionEvents = new EventEmitter()
    this.animationLastRefreshed_ = 0
    this.beginTime_ = this.config_['beginTime']
    this.endTime_ = this.config_['endTime']
    this.firstDataPointTime_ = this.config_['firstDataPointTime']
    this.lastDataPointTime_ = this.config_['lastDataPointTime']
    this.timeLimitsForced_ = this.config_['timeLimitsForced']
    this.defaultTime_ = this.config_['defaultAnimationTime']
    this.endTimeDelay_ = this.config_['endTimeDelay']
    this.frameRate_ = this.config_['frameRate']
    this.refreshInterval_ = this.config_['refreshInterval']
    this.currentTime_ = Date.now()
    this.timeCreatedAt_ = this.currentTime_
    this.animationTime_ = null
    this.animationBeginTime_ = this.config_['beginTime']
    this.animationEndTime_ = this.config_['endTime']
    this.initBeginTime_ = 0
    this.initEndTime_ = 0
    this.animationNumIntervals_ = 0
    this.animationResolutionTime_ = this.config_['resolutionTime']
    this.animationTimes_ = []
    this.animationTimeIndex_ = 0
    this.animationGridTime_ = this.config_['gridTime']
    this.animationGridTimeOffset_ = this.config_['gridTimeOffset']
    this.play_ = false
    this.waitUntilLoaded_ = (this.config_['waitUntilLoaded'] != null) ? this.config_['waitUntilLoaded'] : false
    this.refreshStarted_ = false
    this.continuePlay_ = false
    this.animationBackupTime_ = null
  }

  /**
   * Defines a new timer.
   */
  createTimer () {
    let offsetTime
    let animationTimeIndex = 0
    let defaultTime = this.defaultTime_
    let timeDifference
    let i
    let gridTimes
    let gridTime
    this.animationTimes_ = []
    this.animationNumIntervals_ = 0
    if (this.animationGridTime_ != null) {
      gridTimes = (Array.isArray(this.animationGridTime_)) ? this.animationGridTime_ : [this.animationGridTime_, this.animationGridTime_]
      // Round initial animation time to previous tick
      this.animationBeginTime_ = utils.floorTime(this.beginTime_, gridTimes[0])
      if (this.endTime_ != null) {
        gridTime = (this.animationResolutionTime_ != null) ? this.animationResolutionTime_ : gridTimes[1]
        this.animationEndTime_ = utils.floorTime(this.endTime_, gridTime)
        timeDifference = this.animationEndTime_ - this.animationBeginTime_
      }
      // Time grid offset
      if (this.animationGridTimeOffset_ > 0) {
        offsetTime = this.animationBeginTime_ + this.animationGridTimeOffset_
        if (offsetTime - gridTimes[0] > this.defaultTime_) {
          offsetTime -= gridTimes[0]
        }
        this.animationBeginTime_ = offsetTime
        if (timeDifference != null) {
          this.animationEndTime_ = this.animationBeginTime_ + timeDifference
        }
      }
    } else {
      this.animationBeginTime_ = this.beginTime_
    }
    if (this.animationBeginTime_ != null) {
      defaultTime = Math.max(this.animationBeginTime_, defaultTime)
    }
    if (this.animationEndTime_ != null) {
      defaultTime = Math.min(this.animationEndTime_, defaultTime)
    }
    this.animationTimeIndex_ = 0
    if (this.animationResolutionTime_) {
      this.animationNumIntervals_ = Math.floor((this.animationEndTime_ - this.animationBeginTime_) / this.animationResolutionTime_) + 1
      for (i = 0; i &lt; this.animationNumIntervals_; i++) {
        this.animationTimes_.push(this.animationBeginTime_ + i * this.animationResolutionTime_)
        if (this.animationTimes_[i] &lt;= defaultTime) {
          animationTimeIndex = i
        }
      }
    } else {
      this.animationTimes_ = [this.animationBeginTime_, this.animationEndTime_]
    }
    this.setAnimationTime(this.animationTimes_[animationTimeIndex])
    if (this.initBeginTime_ === 0) {
      this.initBeginTime_ = this.beginTime_
    }
    if (this.initEndTime_ === 0) {
      this.initEndTime_ = this.endTime_
    }
    this.setAnimationLastRefreshed(Date.now())
    if ((this.continuePlay_) || ((this.config_['autoStart']) &amp;&amp; (!this.config_['waitUntilLoaded']))) {
      this.continuePlay_ = false
      this.actionEvents.emitEvent('play')
    }
    if (!this.refreshStarted_) {
      this.refreshStarted_ = true
      this.handleRefresh_()
    }
  }

  /**
   * Performs periodic refreshing.
   */
  handleRefresh_ () {
    let self = this
    let refreshInterval = this.refreshInterval_
    if (!self.play_) {
      this.handleTimer_()
    }
    if (!this.isValidRefreshInterval()) {
      return
    }
    setTimeout(() => {
      self.handleRefresh_()
    }, refreshInterval)
  }

  /**
   * Handles animation timer.
   */
  handleTimer_ () {
    const self = this
    setTimeout(function run () {
      const currentTime = Date.now()
      let timeDelay
      let animationTimeIndex = 0
      if ((self.isValidRefreshInterval()) &amp;&amp; ((currentTime - self.animationLastRefreshed_ > self.refreshInterval_) &amp;&amp; (currentTime - self.timeCreatedAt_ > 0.5 * self.refreshInterval_))) {
        if (self.play_) {
          self.updateAnimationBackupTime()
          self.pause()
          self.continuePlay_ = true
        }
        self.actionEvents.emitEvent('refresh')
      } else if (self.play_) {
        timeDelay = self.frameRate_
        if (self.animationTimeIndex_ === self.animationTimes_.length - 2) {
          timeDelay += self.endTimeDelay_
        }
        if (self.animationTimeIndex_ &lt; self.animationTimes_.length - 1) {
          animationTimeIndex = self.animationTimeIndex_ + 1
        }
        self.setAnimationTime(self.animationTimes_[animationTimeIndex])
        self.updateAnimationBackupTime()
        setTimeout(run, timeDelay)
      } else if (self.animationTime_ &lt; self.animationBeginTime_) {
        self.setAnimationTime(self.animationBeginTime_)
      }
    }, 0)
  }

  /**
   * Sets animation time.
   * @param {number=} animationTime Animation time.
   */
  setAnimationTime (animationTime) {
    let i
    let animationTimeIndex = 0
    let newTime = (animationTime != null) ? animationTime : this.animationTime_
    // Check if animation is initialized correctly
    if (this.animationBeginTime_ > this.animationEndTime_) {
      return
    }
    for (i = 0; i &lt; this.animationTimes_.length; i++) {
      if (newTime &lt;= this.animationTimes_[i]) {
        animationTimeIndex = i
        break
      }
    }
    if (this.animationTimes_.length - 1 >= animationTimeIndex) {
      this.animationTime_ = this.animationTimes_[animationTimeIndex]
      this.animationTimeIndex_ = animationTimeIndex
      this.variableEvents.emitEvent('animationTime', [this.getAnimationTime()])
    }
  }

  /**
   * Gets animation time.
   * @returns {number} Animation time.
   */
  getAnimationTime () {
    return Math.min(this.animationTime_, this.animationEndTime_)
  }

  /**
   * Gets animation begin time.
   * @returns {number} Animation begin time.
   */
  getAnimationBeginTime () {
    return this.animationBeginTime_
  }

  /**
   * Gets animation end time.
   * @returns {number} Animation end time.
   */
  getAnimationEndTime () {
    return this.animationEndTime_
  }

  /**
   * Sets the last animation refresh time.
   * @param newTime Last animation refresh time.
   */
  setAnimationLastRefreshed (newTime) {
    // Todo: from configuration
    const waitTimeForNewImages = 5 * 60 * 1000
    this.animationLastRefreshed_ = newTime
    if (this.isValidRefreshInterval()) {
      this.animationLastRefreshed_ -= newTime % this.refreshInterval_
      if (this.refreshInterval_ > waitTimeForNewImages) {
        this.animationLastRefreshed_ += waitTimeForNewImages
      }
    }
  }

  /**
   * Gets animation resolution time.
   * @returns {number} Animation resolution time.
   */
  getAnimationResolutionTime () {
    return this.animationResolutionTime_
  }

  /**
   * Checks if autostart is currently waiting loading to be finished.
   * @returns {boolean} Waiting autostart.
   */
  isWaitingAutoStart () {
    return this.config_['autoStart'] &amp;&amp; this.waitUntilLoaded_
  }

  /**
   * Gets the number of animation intervals.
   * @returns {number} The number of animation intervals.
   */
  getAnimationNumIntervals () {
    return this.animationNumIntervals_
  }

  /**
   * Gets the real-world creation time.
   * @returns {number} Real-world creation time.
   */
  getCreationTime () {
    return this.timeCreatedAt_
  }

  /**
   * Gets the current real-world time.
   * @returns {number} Current real-world time.
   */
  getCurrentTime () {
    return this.currentTime_
  }

  /**
   * Gets refresh interval.
   * @returns {number} Refresh interval.
   */
  getRefreshInterval () {
    return this.refreshInterval_
  }

  /**
   * Sets the current real-world time.
   * @param currentTime Current real-world time.
   */
  setCurrentTime (currentTime) {
    this.currentTime_ = currentTime
  }

  /**
   * Starts to play animation.
   */
  play () {
    this.waitUntilLoaded_ = false
    if (!this.play_) {
      this.play_ = true
      this.handleTimer_()
    }
  }

  /**
   * Pauses animation.
   */
  pause () {
    this.play_ = false
  }

  /**
   * Stops (pauses and rewinds) animation.
   */
  stop () {
    this.play_ = false
    this.setAnimationTime(this.animationBeginTime_)
  }

  /**
   * Moves to previous time frame.
   */
  previous () {
    let newTime
    let animationTimeIndex = this.animationTimeIndex_
    if (this.animationTimes_.length &lt; 2) {
      return
    }
    if (animationTimeIndex > 0) {
      newTime = this.animationTimes_[animationTimeIndex - 1]
    } else {
      newTime = this.animationTimes_[this.animationTimes_.length - 1]
    }
    this.setAnimationTime(newTime)
    this.updateAnimationBackupTime()
  }

  /**
   * Moves to next time frame.
   */
  next () {
    let newTime
    let animationTimeIndex = this.animationTimeIndex_
    if (this.animationTimes_.length &lt; 2) {
      return
    }
    if (animationTimeIndex &lt; this.animationTimes_.length - 1) {
      newTime = this.animationTimes_[animationTimeIndex + 1]
    } else {
      newTime = this.animationTimes_[0]
    }
    this.setAnimationTime(newTime)
    this.updateAnimationBackupTime()
  }

  /**
   * Changes animation time.
   * @param {number} delta Time change.
   */
  moveAnimationTimeFrame (delta) {
    this.beginTime_ = this.initBeginTime_ + delta
    this.endTime_ = this.initEndTime_ + delta
    if (this.animationTime_ &lt; this.animationBeginTime_) {
      this.setAnimationTime(this.animationBeginTime_)
    }
    this.createTimer()
  }

  /**
   * Sets animations frame rate.
   * @param {number} frameRate Frame rate.
   */
  setFrameRate (frameRate) {
    this.frameRate_ = frameRate
    this.play_ = false
  }

  /**
   * Sets animation grid time.
   * @param {number} gridTime Animation grid time.
   */
  setGridTime (gridTime) {
    this.animationGridTime_ = gridTime
    this.createTimer()
  }

  /**
   * Sets animation begin time.
   * @param {number} beginTime Animation begin time.
   */
  setBeginTime (beginTime) {
    this.beginTime_ = beginTime
    this.initBeginTime_ = 0
    this.createTimer()
  }

  /**
   * Sets animation end time.
   * @param {number} endTime Animation end time.
   */
  setEndTime (endTime) {
    this.endTime_ = endTime
    this.initEndTime_ = 0
    this.createTimer()
  }

  /**
   * Sets the time of first available datapoint
   * @param {number} firstDataPointTime first available datapoint time
   */
  setFirstDataPointTime (firstDataPointTime) {
    this.firstDataPointTime_ = firstDataPointTime
    this.createTimer()
  }

  /**
   * Sets the time of last available datapoint
   * @param {number} lastDataPointTime last available datapoint time
   */
  setLastDataPointTime (lastDataPointTime) {
    this.lastDataPointTime_ = lastDataPointTime
    this.createTimer()
  }
  /**
   * Sets time limits forced.
   * @param {boolean} timeLimitsForced Time limits forced.
   */
  setTimeLimitsForced (timeLimitsForced) {
    this.timeLimitsForced_ = timeLimitsForced
    this.createTimer()
  }

  /**
   * Gets time limits forced.
   * @returns {boolean} Time limits forced.
   */
  getTimeLimitsForced () {
    return this.timeLimitsForced_
  }

  /**
   * Sets animation resolution time.
   * @param resolutionTime Resolution time.
   */
  setResolutionTime (resolutionTime) {
    this.animationResolutionTime_ = resolutionTime
    this.createTimer()
  }

  /**
   * Sets animation default time.
   * @param defaultTime Default time.
   */
  setDefaultTime (defaultTime) {
    this.defaultTime_ = defaultTime
  }

  /**
   * Sets time grid offset from midnight.
   * @param gridTimeOffset {Number} Time grid offset.
   */
  setDayStartOffset (gridTimeOffset) {
    this.animationGridTimeOffset_ = gridTimeOffset
    this.createTimer()
  }

  /**
   * Sets animation time moments.
   * @param animationTimes {array} Animation time moments.
   */
  setAnimationTimes (animationTimes) {
    let i
    let numAnimationTimes = animationTimes.length
    let updateNeeded = (numAnimationTimes !== this.animationTimes_.length)
    let maxAnimationTime
    if (!updateNeeded) {
      for (i = 0; i &lt; numAnimationTimes; i++) {
        if (this.animationTimes_[i] !== animationTimes[i]) {
          updateNeeded = true
          break
        }
      }
    }
    if (this.defaultTime_ &lt; this.animationTimes_[0]) {
      this.defaultTime_ = this.animationTimes_[0]
    }
    maxAnimationTime = this.animationTimes_[numAnimationTimes - 1]
    if (this.defaultTime_ > maxAnimationTime) {
      this.defaultTime_ = maxAnimationTime
    }
    if (this.defaultTime_ &lt; this.animationTimes_[0]) {
      this.defaultTime_ = this.animationTimes_[0]
    }
    maxAnimationTime = this.animationTimes_[numAnimationTimes - 1]
    if (this.defaultTime_ > maxAnimationTime) {
      this.defaultTime_ = maxAnimationTime
    }
    if (updateNeeded) {
      this.animationTimes_ = animationTimes
      this.setAnimationTime(isNumeric(this.animationTime_) ? this.animationTime_ : this.defaultTime_)
    }
  }

  /**
   * Gets animation times as an array.
   * @returns {Array|*} Animation times.
   */
  getAnimationTimes () {
    return this.animationTimes_
  }

  /**
   * Gets Time Configuration from Time model
   * @returns Array of time parameters.
   */
  getTimeConfiguration () {
    let config = {}
    config.beginTime = this.beginTime_
    config.endTime = this.endTime_
    config.firstDataPointTime = this.firstDataPointTime_
    config.lastDataPointTime = this.lastDataPointTime_
    config.resolutionTime = this.animationResolutionTime_
    return config
  }

  /**
   * Gets animation backup time.
   * @returns {number} Animation backup time.
   */
  getAnimationBackupTime () {
    return this.animationBackupTime_
  }

  /**
   * Updates animation backup time.
   * @param time {number} Timestamp of animation backup time.
   */
  updateAnimationBackupTime () {
    this.animationBackupTime_ = this.getAnimationTime()
  }

  /**
   * Check the refresh interval validity.
   */
  isValidRefreshInterval () {
    let refreshInterval = this.refreshInterval_
    return ((refreshInterval != null) &amp;&amp; (typeof refreshInterval === 'number') &amp;&amp; (refreshInterval > 0) &amp;&amp; (refreshInterval &lt;= constants.MAX_REFRESH_INTERVAL))
  }

  /**
   * Updates animation backup time.
   */
  resetAnimationBackupTime () {
    this.animationBackupTime_ = null
  }

  /**
   * Destroys current timer.
   */
  destroyTimer () {
    this.play_ = false
    this.variableEvents.removeAllListeners()
    this.actionEvents.removeAllListeners()
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Base.html">Base</a></li><li><a href="Html.html">Html</a></li><li><a href="Internal.html">Internal</a></li><li><a href="MetOClient_MetOClient.html">MetOClient</a></li><li><a href="module.exports.html">exports</a></li><li><a href="module.exports_module.exports.html">exports</a></li><li><a href="TimeFrame.module.exports.html">module.exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addFeatures">addFeatures</a></li><li><a href="global.html#clear">clear</a></li><li><a href="global.html#clearFeatures">clearFeatures</a></li><li><a href="global.html#configureTicks">configureTicks</a></li><li><a href="global.html#createContainers">createContainers</a></li><li><a href="global.html#createFrame">createFrame</a></li><li><a href="global.html#createFrames">createFrames</a></li><li><a href="global.html#createIndicators">createIndicators</a></li><li><a href="global.html#createMap">createMap</a></li><li><a href="global.html#createMenu">createMenu</a></li><li><a href="global.html#createPointer">createPointer</a></li><li><a href="global.html#createPostTools">createPostTools</a></li><li><a href="global.html#createPreMargin">createPreMargin</a></li><li><a href="global.html#createPreTools">createPreTools</a></li><li><a href="global.html#createTicks">createTicks</a></li><li><a href="global.html#createTime">createTime</a></li><li><a href="global.html#createTimeMenu">createTimeMenu</a></li><li><a href="global.html#createTimer">createTimer</a></li><li><a href="global.html#createTimeSlider">createTimeSlider</a></li><li><a href="global.html#createTimeZoneLabel">createTimeZoneLabel</a></li><li><a href="global.html#destroyAnimation">destroyAnimation</a></li><li><a href="global.html#destroyTime">destroyTime</a></li><li><a href="global.html#destroyTimer">destroyTimer</a></li><li><a href="global.html#destroyTimeSlider">destroyTimeSlider</a></li><li><a href="global.html#featureFactory">featureFactory</a></li><li><a href="global.html#filters">filters</a></li><li><a href="global.html#floorTime">floorTime</a></li><li><a href="global.html#getAnimationBackupTime">getAnimationBackupTime</a></li><li><a href="global.html#getAnimationBeginTime">getAnimationBeginTime</a></li><li><a href="global.html#getAnimationEndTime">getAnimationEndTime</a></li><li><a href="global.html#getAnimationNumIntervals">getAnimationNumIntervals</a></li><li><a href="global.html#getAnimationResolutionTime">getAnimationResolutionTime</a></li><li><a href="global.html#getAnimationTime">getAnimationTime</a></li><li><a href="global.html#getAnimationTimes">getAnimationTimes</a></li><li><a href="global.html#getCapabilities">getCapabilities</a></li><li><a href="global.html#getCreationTime">getCreationTime</a></li><li><a href="global.html#getCurrentTime">getCurrentTime</a></li><li><a href="global.html#getFeatures">getFeatures</a></li><li><a href="global.html#getFeaturesAt">getFeaturesAt</a></li><li><a href="global.html#getLayer">getLayer</a></li><li><a href="global.html#getLayerConfigs">getLayerConfigs</a></li><li><a href="global.html#getLayers">getLayers</a></li><li><a href="global.html#getMap">getMap</a></li><li><a href="global.html#getRefreshInterval">getRefreshInterval</a></li><li><a href="global.html#getStaticControls">getStaticControls</a></li><li><a href="global.html#getTickText">getTickText</a></li><li><a href="global.html#getTimeConfiguration">getTimeConfiguration</a></li><li><a href="global.html#getTimeLimitsForced">getTimeLimitsForced</a></li><li><a href="global.html#handleRefresh_">handleRefresh_</a></li><li><a href="global.html#handleTimer_">handleTimer_</a></li><li><a href="global.html#hidePopup">hidePopup</a></li><li><a href="global.html#isValidRefreshInterval">isValidRefreshInterval</a></li><li><a href="global.html#isWaitingAutoStart">isWaitingAutoStart</a></li><li><a href="global.html#layerFactory">layerFactory</a></li><li><a href="global.html#LEGEND_CONTAINER_CLASS">LEGEND_CONTAINER_CLASS</a></li><li><a href="global.html#LEGEND_FIGURE_CLASS_PREFIX">LEGEND_FIGURE_CLASS_PREFIX</a></li><li><a href="global.html#loadCapabilities">loadCapabilities</a></li><li><a href="global.html#loadFunction">loadFunction</a></li><li><a href="global.html#LOADING_STATUS">LOADING_STATUS</a></li><li><a href="global.html#MAX_TIMESTAMP">MAX_TIMESTAMP</a></li><li><a href="global.html#moveAnimationTimeFrame">moveAnimationTimeFrame</a></li><li><a href="global.html#next">next</a></li><li><a href="global.html#pause">pause</a></li><li><a href="global.html#play">play</a></li><li><a href="global.html#previous">previous</a></li><li><a href="global.html#produceFullLayerConfig">produceFullLayerConfig</a></li><li><a href="global.html#refreshLayers">refreshLayers</a></li><li><a href="global.html#refreshMap">refreshMap</a></li><li><a href="global.html#refreshTime">refreshTime</a></li><li><a href="global.html#requestViewUpdate">requestViewUpdate</a></li><li><a href="global.html#resetAnimationBackupTime">resetAnimationBackupTime</a></li><li><a href="global.html#selectFeature">selectFeature</a></li><li><a href="global.html#setAnimationLastRefreshed">setAnimationLastRefreshed</a></li><li><a href="global.html#setAnimationPlay">setAnimationPlay</a></li><li><a href="global.html#setAnimationTime">setAnimationTime</a></li><li><a href="global.html#setAnimationTimes">setAnimationTimes</a></li><li><a href="global.html#setBeginTime">setBeginTime</a></li><li><a href="global.html#setCallbacks">setCallbacks</a></li><li><a href="global.html#setCapabilities">setCapabilities</a></li><li><a href="global.html#setCenter">setCenter</a></li><li><a href="global.html#setCurrentTime">setCurrentTime</a></li><li><a href="global.html#setDayStartOffset">setDayStartOffset</a></li><li><a href="global.html#setDefaultTime">setDefaultTime</a></li><li><a href="global.html#setDragging">setDragging</a></li><li><a href="global.html#setEndTime">setEndTime</a></li><li><a href="global.html#setFirstDataPointTime">setFirstDataPointTime</a></li><li><a href="global.html#setFrameRate">setFrameRate</a></li><li><a href="global.html#setGridTime">setGridTime</a></li><li><a href="global.html#setInteractions">setInteractions</a></li><li><a href="global.html#setLastDataPointTime">setLastDataPointTime</a></li><li><a href="global.html#setLayers">setLayers</a></li><li><a href="global.html#setLayerVisible">setLayerVisible</a></li><li><a href="global.html#setMarkerVisible">setMarkerVisible</a></li><li><a href="global.html#setResolutionTime">setResolutionTime</a></li><li><a href="global.html#setRotation">setRotation</a></li><li><a href="global.html#setStaticControls">setStaticControls</a></li><li><a href="global.html#setTimeLimitsForced">setTimeLimitsForced</a></li><li><a href="global.html#setTimeStep">setTimeStep</a></li><li><a href="global.html#setTimeZone">setTimeZone</a></li><li><a href="global.html#setTimeZoneLabel">setTimeZoneLabel</a></li><li><a href="global.html#setZoom">setZoom</a></li><li><a href="global.html#showPopup">showPopup</a></li><li><a href="global.html#showTicks">showTicks</a></li><li><a href="global.html#sourceFactory">sourceFactory</a></li><li><a href="global.html#step">step</a></li><li><a href="global.html#stop">stop</a></li><li><a href="global.html#styleFactory">styleFactory</a></li><li><a href="global.html#supportOldBrowsers">supportOldBrowsers</a></li><li><a href="global.html#transformCoordinates">transformCoordinates</a></li><li><a href="global.html#updateAnimationBackupTime">updateAnimationBackupTime</a></li><li><a href="global.html#updateLayers">updateLayers</a></li><li><a href="global.html#updatePointer">updatePointer</a></li><li><a href="global.html#updateTimeLoaderVis">updateTimeLoaderVis</a></li><li><a href="global.html#updateTimeLoaderVisualizations">updateTimeLoaderVisualizations</a></li><li><a href="global.html#updateTimeSlider">updateTimeSlider</a></li><li><a href="global.html#updateTimeSteps">updateTimeSteps</a></li><li><a href="global.html#urlToDataUrl">urlToDataUrl</a></li><li><a href="global.html#ZINDEX">ZINDEX</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.2</a> on Sat Jul 27 2019 13:10:22 GMT+0300 (Eastern European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
