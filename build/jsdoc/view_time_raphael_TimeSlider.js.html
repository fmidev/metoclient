<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: view/time/raphael/TimeSlider.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: view/time/raphael/TimeSlider.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Raphael implementation of time view.
 * @author FMI
 */

import EventEmitter from 'wolfy87-eventemitter'
import Raphael from 'raphael'
import moment from 'moment-timezone'
import fi from 'moment/locale/fi'
import sv from 'moment/locale/sv'
import uk from 'moment/locale/uk'
import jQuery from 'jquery'
import 'jquery-mousewheel'
// import Interface from 'contracts-es6';
// import Slider from '../../interfaces/Slider';

// export default class TimeSlider extends Interface.StrictInterface(Slider) {
export default class TimeSlider {
  /**
   * Constructs Raphael based time view.
   * @param {string} container Time slider container.
   * @param {Object} config Configuration for time view.
   * @extends {goog.Disposable}
   * @implements {fi.fmi.metoclient.ui.animator.view.interfaces.TimeSlider}
   * @constructor
   */
  constructor (config, container) {
    // super();
    this.config_ = config
    this.container_ = container
    this.paper_ = null
    this.visualPointer_ = null
    this.frameWidth_ = 0
    this.playPauseButton_ = null
    this.frameStatusRects_ = null
    this.animationTime_ = null
    this.animationPlay_ = false
    this.beginTime_ = null
    this.endTime_ = null
    this.resolutionTime_ = null
    this.timeZone_ = config['timeZone']
    this.timeZoneLabel_ = config['timeZoneLabel']
    this.animationPlayListener_ = null
    this.actionEvents = new EventEmitter()
    this.variableEvents = new EventEmitter()
  };

// Todo: jaa pienemmiksi funktioiksi
  /** @inheritDoc */
  createTimeSlider (currentTime, animationTime, beginTime, endTime, resolutionTime, numIntervals) {
    const self = this
    let containerWidth,
      frameWidth,
      frameHeight,
      paperWidth,
      paperHeight,
      paper,
      sliderWidth,
      sliderOffset,
      labelPhase,
      labelStart,
      hourDiff,
      phaseDiff,
      playButtonBackground,
      background,
      imagePath,
      playPauseButton,
      past,
      frameStatusRects,
      tickTexts,
      previousTime,
      time,
      date,
      i,
      x,
      y,
      tickText,
      tick,
      tickHeight,
      timeLabel,
      pastWidth,
      futureWidth,
      x0,
      x1,
      x2,
      x3,
      x4,
      y0,
      y1,
      y2,
      pointer,
      pointerLabel,
      pointerSet,
      pixelTime,
      movePointerDrag,
      movePointerTouch,
      upPointerDrag,
      clickableArea,
      startPointerDrag,
      startPointerTouch,
      logo
    if (!this.config_['showTimeSlider']) {
      return
    }
    this.animationTime_ = animationTime
    if (beginTime > endTime) {
      return
    }
    this.beginTime_ = beginTime
    this.endTime_ = endTime
    if (resolutionTime === 0) {
      return
    }
    this.resolutionTime_ = resolutionTime
    if (numIntervals === 0) {
      return
    }
    if (this.animationPlayListener_ === null) {
      this.initAnimationPlayListener()
    }
    jQuery(this.container_).empty()
    containerWidth = Math.max(jQuery(this.container_).width(), 1)
    sliderOffset = this.config_['sliderOffset']
    sliderWidth = Math.max(containerWidth - this.config_['imageWidth'] - 2 * sliderOffset, 1)
    frameWidth = numIntervals ? sliderWidth / numIntervals : null
    this.frameWidth_ = frameWidth
    frameHeight = this.config_['sliderHeight'] - this.config_['statusHeight']
    paperWidth = containerWidth
    paperHeight = this.config_['imageHeight'] + this.config_['pointerHeight']
    labelPhase = Math.max(Math.round(5 * this.config_['tickTextSize'] / frameWidth), 1)
    paper = Raphael(this.container_, containerWidth, paperHeight)
    paper.canvas.style.strokeWidth = '0'
    paper.canvas.style.position = 'absolute'
    paper.canvas.style.top = ''
    paper.canvas.style.left = '0'
    paper.canvas.style.bottom = '0'
    paper.canvas.style.width = '100%'
    playButtonBackground = paper.path(`M${sliderOffset} 0 l0 ${this.config_['imageHeight']}l${this.config_['imageWidth']} 0l0 -${this.config_['imageHeight']}Z`).attr({
      'fill': this.config_['imageBackgroundColor']
    }).mouseover(function (e) {
      this.attr({'fill': self.config_['imageHoverColor']})
    })
    background = paper.path(`M${sliderOffset + this.config_['imageWidth']} 0 l0 ${this.config_['imageHeight']}l${sliderWidth} 0l0 -${this.config_['imageHeight']}Z`).attr({
      'fill': '#FFFFFF'
    })
    background.node.id = 'fmi-animator-timeslider-background'
    imagePath = this.animationPlay_ ? this.config_['pauseImagePath'] : this.config_['playImagePath']
    playPauseButton = paper.image(imagePath, sliderOffset, 0, this.config_['imageWidth'], this.config_['imageHeight']).attr({
      'cursor': 'pointer'
    }).click(e => {
      self.animationPlay_ = !self.animationPlay_
      self.variableEvents.emitEvent('animationPlay', [self.animationPlay_])
    }).hover(e => {
      playButtonBackground.attr({
        'fill': self.config_['imageHoverColor']
      })
    }, e => {
      playButtonBackground.attr({'fill': self.config_['imageBackgroundColor']})
    })
    this.playPauseButton_ = playPauseButton
    labelStart = 0
    for (i = 1; i &lt; numIntervals; i++) {
      date = new Date(beginTime + i * resolutionTime)
      if ((date.getMinutes() === 0) &amp;&amp; (date.getSeconds() === 0) &amp;&amp; (date.getMilliseconds() === 0)) {
        if (labelStart === 0) {
          labelStart = i
        } else {
          hourDiff = i - labelStart
          if (labelPhase &lt;= hourDiff) {
            phaseDiff = hourDiff % labelPhase
            if (phaseDiff !== 0) {
              labelPhase = hourDiff
            }
          } else {
            labelPhase += hourDiff - labelPhase % hourDiff
          }
          break
        }
      }
    }
    past = 0
    frameStatusRects = []
    tickTexts = []
    previousTime = null
    for (i = -1; i &lt; numIntervals; i++) {
      time = beginTime + i * resolutionTime
      if (time &lt;= currentTime) {
        past = i + 1
      }
      if (i === numIntervals - 1) {
        break
      }
      x = sliderOffset + this.config_['imageWidth'] + (i + 1) * frameWidth
      // Status color bars
      frameStatusRects.push(paper.rect(x, frameHeight, frameWidth, this.config_['statusHeight']).attr({
        'fill': this.config_['loadedColor']
      }))
      // Skip the first tick and label
      if (i === -1) {
        continue
      }
      y = this.config_['statusHeight']
      if ((i - labelStart) % labelPhase === 0) {
        tickText = this.getTickText(time, previousTime)
        y = this.config_['tickHeight']
        tickHeight = this.config_['tickHeight']
        timeLabel = paper.text(x, this.config_['tickTextYOffset'], tickText).attr({
          'fill': this.config_['tickTextColor'],
          'font-size': Math.max(this.config_['tickTextSize'], this.config_['tickTextSize'])
        })
        previousTime = time
      } else {
        tickText = ''
        tickHeight = this.config_['statusHeight']
      }
      tickTexts.push(tickText)
      y = frameHeight + this.config_['statusHeight'] - y
      tick = paper.path(`M${x} ${y}l0 ${tickHeight}`).attr({
        'stroke': this.config_['tickColor'],
        'stroke-width': '1'
      })
    }
    this.frameStatusRects_ = frameStatusRects
    pastWidth = past * frameWidth
    futureWidth = sliderWidth - pastWidth
    if (futureWidth &lt; 1.0e-5) {
      futureWidth = 0
    }
    paper.rect(sliderOffset + this.config_['imageWidth'], 0, pastWidth, frameHeight).attr({
      'fill': this.config_['pastColor']
    }).toBack()
    paper.rect(sliderOffset + this.config_['imageWidth'] + pastWidth, 0, futureWidth, frameHeight).attr({
      'fill': this.config_['futureColor']
    }).toBack()

    // Time zone label
    paper.text(paperWidth - this.config_['sliderOffset'] - 1, frameHeight - 0.5 * this.config_['tickTextSize'] - 1, this.timeZoneLabel_).attr({
      'text-anchor': 'end',
      'color': this.config_['tickTextColor'],
      'font-size': this.config_['tickTextSize']
    })

    // Create pointer
    x0 = sliderOffset + this.config_['imageWidth']
    x1 = x0 + this.config_['statusHeight']
    x2 = x0 + 0.5 * this.config_['pointerWidth']
    x3 = x0 - 0.5 * this.config_['pointerWidth']
    x4 = x0 - this.config_['statusHeight']
    y0 = frameHeight
    y1 = y0 + this.config_['statusHeight']
    y2 = y1 + this.config_['pointerHeight']
    pointer = paper.path(`M${x0} ${y0}L${x1} ${y1}L${x2} ${y1}L${x2} ${y2}L${x3} ${y2}L${x3} ${y1}L${x4} ${y1}Z`)
    pointer['attr']({
      'fill': this.config_['pointerColor'],
      'stroke': this.config_['pointerStrokeColor'],
      'stroke-width': '1',
      'cursor': 'pointer'
    })
    pointerLabel = paper.text(x0, y2 - this.config_['pointerTextOffset'], '').attr({
      'fill': this.config_['pointerTextColor'],
      'font-size': this.config_['pointerTextSize'],
      'font-weight': 'bold',
      'cursor': 'pointer'
    })
    pointerSet = paper.set()
    pointerSet.push(
      pointer,
      pointerLabel
    )
    startPointerDrag = ({pageX}) => {
      pointer.startDragTime = self.animationTime_
      pointer.startDragX = pageX
    }
    startPointerTouch = ({touches}) => {
      pointer.startDragTime = self.animationTime_
      pointer.startDragX = touches[0].clientX
    }
    pixelTime = resolutionTime / frameWidth
    movePointerDrag = ({pageX}) => {
      let newTime, dx
      if (pointer.startDragX == null) {
        return
      }
      dx = pageX - pointer.startDragX
      if (paperWidth === 0) {
        return
      }
      if (!self.animationPlay_) {
        newTime = pointer.startDragTime + dx * pixelTime
        newTime = Math.min(newTime, self.endTime_)
        newTime = Math.max(newTime, self.beginTime_)
        self.variableEvents.emitEvent('animationTime', [newTime])
      }
    }
    movePointerTouch = ({originalEvent}) => {
      let newTime, dx
      if (pointer.startDragX == null) {
        return
      }
      dx = originalEvent.touches[0].clientX - pointer.startDragX
      if (paperWidth === 0) {
        return
      }
      if (!self.animationPlay_) {
        newTime = Math.min(pointer.startDragTime + dx * pixelTime, self.endTime_)
        self.variableEvents.emitEvent('animationTime', [newTime])
      }
    }
    upPointerDrag = () => {
      pointer.startDragX = null
      let animationTime = beginTime + Math.round((self.animationTime_ - beginTime) / resolutionTime) * resolutionTime
      if (animationTime &lt; beginTime) {
        animationTime = beginTime
      }
      self.variableEvents.emitEvent('animationTime', [animationTime])
    }
    pointer['mousedown'](startPointerDrag)
    pointerLabel['mousedown'](startPointerDrag)
    pointer['touchstart'](startPointerTouch)
    pointerLabel['touchstart'](startPointerDrag)
    jQuery(document).off('mousemove', movePointerDrag).on('mousemove', movePointerDrag)
    jQuery(document).off('touchmove', movePointerTouch).on('touchmove', movePointerTouch)
    jQuery(document).off('mouseup', upPointerDrag).on('mouseup', upPointerDrag)
    jQuery(document).off('touchend', upPointerDrag).on('touchend', upPointerDrag)
    clickableArea = paper.rect(0, 0, paperWidth, this.config_['imageHeight']).attr({
      'fill': this.config_['imageBackgroundColor'],
      'fill-opacity': '0',
      'cursor': 'pointer'
    }).mousedown(({offsetX, layerX}) => {
      let x, xt
      if (pixelTime === 0) {
        return
      }
      if (paperWidth === 0) {
        return
      }
      self.animationPlay_ = false
      self.variableEvents.emitEvent('animationPlay', [self.animationPlay_])
      x = offsetX || layerX
      xt = sliderOffset + frameWidth + self.config_['imageWidth'] + (self.animationTime_ - beginTime) / pixelTime
      if (x &lt; xt) {
        self.actionEvents.emitEvent('previous')
      } else if (xt &lt; x) {
        self.actionEvents.emitEvent('next')
      }
    })
    // Mouse wheel
    jQuery(clickableArea.node).bind('mousewheel', (event, delta) => {
      if (delta > 0) {
        // Scrolling up.
        self.actionEvents.emitEvent('next')
      } else if (delta &lt; 0) {
        // Scrolling down.
        self.actionEvents.emitEvent('previous')
      }
      // Prevent scrolling of the page.
      return false
    })
    if (this.config_.logoPath) {
      jQuery(this.container_)
      logo = jQuery('&lt;img id="metoclient-logo" src="' + this.config_.logoPath + '" />').css({
        'float': 'right',
        'margin-right': sliderOffset
      })
      jQuery(this.container_).append(logo)
    }
    this.paper_ = paper
    this.visualPointer_ = pointerSet
    this.updatePointer(animationTime)
    playPauseButton.toFront()
    pointerSet.toFront()
    background.toBack()
  };

  /**
   * Sets pointer time.
   * @param {number} time Time value.
   */
  setPointerTime (time) {
    this.visualPointer_.time = time
  };

  /**
   * Set pointer text.
   * @param {number} time Time value.
   */
  setPointerText (time) {
    this.visualPointer_.attr('text', this.getTickText(time))
  };

  /**
   * Move pointer element on the time slider.
   * @param dx Horizontal displacement.
   */
  movePointer (dx) {
    this.visualPointer_.transform(`T${dx},0`)
  };

// todo: siirrä tämä funktio omaan yläluokkaansa, koska ei ole Raphael-riippuvainen
  /**
   * Generate text presentation of the given time.
   * @param {number} tickTime Time value.
   * @param {number|null=} prevTime Previous time value.
   * @returns {string} Generated text presentation.
   */
  getTickText (tickTime, prevTime) {
    const beginTime = this.beginTime_
    const resolutionTime = this.resolutionTime_
    let zTime
    let zPrevTime
    let day
    let year
    let currentMoment
    let format = 'HH:mm'
    const dateFormat = 'dd D.M.'
    if (beginTime == null) {
      return ''
    }
    if (tickTime &lt; beginTime) {
      tickTime = beginTime
    }
    moment.locale(this.config_['locale'])
    zTime = moment(beginTime + Math.ceil((tickTime - beginTime) / resolutionTime) * resolutionTime).tz(this.timeZone_)
    day = zTime.dayOfYear()
    year = zTime.year()
    currentMoment = moment()
    if (prevTime != null) {
      zPrevTime = moment(prevTime).tz(this.timeZone_)
      if ((day !== zPrevTime.dayOfYear()) || (year !== zPrevTime.year())) {
        format = dateFormat
      }
    } else if ((typeof prevTime !== 'undefined') &amp;&amp; ((day !== currentMoment.dayOfYear()) || (year !== currentMoment.year()))) {
      format = dateFormat
    }
    return zTime.format(format)
  };

  /** @inheritDoc */
  setAnimationTime (animationTime) {
    this.animationTime_ = animationTime
    this.updatePointer(animationTime)
  };

  /**
   * Updates pointer text and location on the time slider.
   * @param animationTime Time value.
   */
  updatePointer (animationTime) {
    const dx = this.frameWidth_ * (1 + (animationTime - this.beginTime_) / this.resolutionTime_)
    this.movePointer(dx)
    this.setPointerTime(animationTime)
    this.setPointerText(animationTime)
  };

  /** @inheritDoc */
  updateTimeLoaderVis (numIntervalItems) {
    if (!this.config_['showTimeSlider']) {
      return
    }
    const len = Math.min(this.frameStatusRects_.length, numIntervalItems.length)
    for (let i = 0; i &lt; len; i++) {
      switch (numIntervalItems[i].status) {
        case 'Loading':
          this.frameStatusRects_[i].attr({
            'fill': this.config_['loadingColor']
          })
          break
        case 'Ready':
          this.frameStatusRects_[i].attr({
            'fill': this.config_['loadedColor']
          })
          break
        case 'Error':
          this.frameStatusRects_[i].attr({
            'fill': this.config_['loadingErrorColor']
          })
          break
        default:
          this.frameStatusRects_[i].attr({
            'fill': this.config_['notLoadedColor']
          })
      }
    }
  };

  /**
   * Initialize button listener.
   */
  initAnimationPlayListener () {
    const self = this
    // Update button image
    this.animationPlayListener_ = play => {
      self.playPauseButton_.attr('src', self.config_[play ? 'pauseImagePath' : 'playImagePath'])
    }
    this.variableEvents.addListener('animationPlay', this.animationPlayListener_)
  };

  /** @inheritDoc */
  setAnimationPlay (animationPlay) {
    this.animationPlay_ = animationPlay
    if (this.playPauseButton_ == null) {
      return
    }
    if (animationPlay) {
      this.playPauseButton_.attr({
        'src': this.config_['pauseImagePath']
      })
      this.playPauseButton_.node.href.baseVal = this.config_['pauseImagePath']
    } else {
      this.playPauseButton_.attr({
        'src': this.config_['playImagePath']
      })
    }
  };

  /** @inheritDoc */
  setTimeZone (timeZone) {
    this.timeZone_ = timeZone
  };

  /** @inheritDoc */
  setTimeZoneLabel (timeZoneLabel) {
    this.timeZoneLabel_ = timeZoneLabel
  };

  /** @inheritDoc */
  destroyTimeSlider () {
    this.actionEvents.removeAllListeners()
    this.variableEvents.removeAllListeners()
    if (this.paper_ != null) {
      this.paper_.clear()
      this.paper_ = null
    }
    jQuery(this.container_).empty()
  };
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="MetOClient.html">MetOClient</a></li><li><a href="module.exports.html">exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addFeatures">addFeatures</a></li><li><a href="global.html#clearFeatures">clearFeatures</a></li><li><a href="global.html#createAnimation">createAnimation</a></li><li><a href="global.html#createMap">createMap</a></li><li><a href="global.html#createTime">createTime</a></li><li><a href="global.html#createTimer">createTimer</a></li><li><a href="global.html#createTimeSlider">createTimeSlider</a></li><li><a href="global.html#destroyAnimation">destroyAnimation</a></li><li><a href="global.html#destroyTime">destroyTime</a></li><li><a href="global.html#destroyTimer">destroyTimer</a></li><li><a href="global.html#destroyTimeSlider">destroyTimeSlider</a></li><li><a href="global.html#floorTime">floorTime</a></li><li><a href="global.html#getAnimationBeginTime">getAnimationBeginTime</a></li><li><a href="global.html#getAnimationEndTime">getAnimationEndTime</a></li><li><a href="global.html#getAnimationNumIntervals">getAnimationNumIntervals</a></li><li><a href="global.html#getAnimationResolutionTime">getAnimationResolutionTime</a></li><li><a href="global.html#getAnimationTime">getAnimationTime</a></li><li><a href="global.html#getCapabilities">getCapabilities</a></li><li><a href="global.html#getCreationTime">getCreationTime</a></li><li><a href="global.html#getCurrentTime">getCurrentTime</a></li><li><a href="global.html#getFeatures">getFeatures</a></li><li><a href="global.html#getFeaturesAt">getFeaturesAt</a></li><li><a href="global.html#getLayer">getLayer</a></li><li><a href="global.html#getLayers">getLayers</a></li><li><a href="global.html#getMap">getMap</a></li><li><a href="global.html#getRefreshInterval">getRefreshInterval</a></li><li><a href="global.html#getStaticControls">getStaticControls</a></li><li><a href="global.html#getTickText">getTickText</a></li><li><a href="global.html#hidePopup">hidePopup</a></li><li><a href="global.html#initAnimationPlayListener">initAnimationPlayListener</a></li><li><a href="global.html#isWaitingAutoStart">isWaitingAutoStart</a></li><li><a href="global.html#LEGEND_FIGURE_CLASS_PREFIX">LEGEND_FIGURE_CLASS_PREFIX</a></li><li><a href="global.html#loadCapabilities">loadCapabilities</a></li><li><a href="global.html#LOADING_STATUS">LOADING_STATUS</a></li><li><a href="global.html#MAP_LAYER_SWITCHER_ID">MAP_LAYER_SWITCHER_ID</a></li><li><a href="global.html#MAX_TIMESTAMP">MAX_TIMESTAMP</a></li><li><a href="global.html#moveAnimationTimeFrame">moveAnimationTimeFrame</a></li><li><a href="global.html#movePointer">movePointer</a></li><li><a href="global.html#next">next</a></li><li><a href="global.html#pause">pause</a></li><li><a href="global.html#play">play</a></li><li><a href="global.html#previous">previous</a></li><li><a href="global.html#refreshLayers">refreshLayers</a></li><li><a href="global.html#refreshMap">refreshMap</a></li><li><a href="global.html#refreshTime">refreshTime</a></li><li><a href="global.html#requestViewUpdate">requestViewUpdate</a></li><li><a href="global.html#setAnimationLastRefreshed">setAnimationLastRefreshed</a></li><li><a href="global.html#setAnimationPlay">setAnimationPlay</a></li><li><a href="global.html#setAnimationTime">setAnimationTime</a></li><li><a href="global.html#setBeginTime">setBeginTime</a></li><li><a href="global.html#setCallbacks">setCallbacks</a></li><li><a href="global.html#setCapabilities">setCapabilities</a></li><li><a href="global.html#setCenter">setCenter</a></li><li><a href="global.html#setCurrentTime">setCurrentTime</a></li><li><a href="global.html#setDayStartOffset">setDayStartOffset</a></li><li><a href="global.html#setEndTime">setEndTime</a></li><li><a href="global.html#setFrameRate">setFrameRate</a></li><li><a href="global.html#setInteractions">setInteractions</a></li><li><a href="global.html#setLayers">setLayers</a></li><li><a href="global.html#setLayerVisible">setLayerVisible</a></li><li><a href="global.html#setPointerText">setPointerText</a></li><li><a href="global.html#setPointerTime">setPointerTime</a></li><li><a href="global.html#setResolutionTime">setResolutionTime</a></li><li><a href="global.html#setRotation">setRotation</a></li><li><a href="global.html#setStaticControls">setStaticControls</a></li><li><a href="global.html#setTimeStep">setTimeStep</a></li><li><a href="global.html#setTimeZone">setTimeZone</a></li><li><a href="global.html#setTimeZoneLabel">setTimeZoneLabel</a></li><li><a href="global.html#setZoom">setZoom</a></li><li><a href="global.html#showPopup">showPopup</a></li><li><a href="global.html#startTimer">startTimer</a></li><li><a href="global.html#stop">stop</a></li><li><a href="global.html#supportOldBrowsers">supportOldBrowsers</a></li><li><a href="global.html#updatePointer">updatePointer</a></li><li><a href="global.html#updateTimeLoaderVis">updateTimeLoaderVis</a></li><li><a href="global.html#updateTimeSlider">updateTimeSlider</a></li><li><a href="global.html#zIndex">zIndex</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Fri Oct 20 2017 12:32:49 GMT+0300 (EEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
